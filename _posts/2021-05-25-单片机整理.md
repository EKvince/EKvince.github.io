**一、**  **概述**

计算机基本模型：**图灵理论模型**。

图灵的基本思想是用机器来模拟人用纸笔进行数学运算的过程：在纸上写或擦去某个符号；把注意力从纸上的一个方向移动到另一个方向。

组成：

1)       一条无限长的纸带

2)       一个读写头，可移动，能改变格子上的符号

3)       一套控制规则，根据当前状态及当前格子上的符号来确定读写头下一步的动作

4)       一个状态寄存器，状态数有限

图灵机模型的思想奠定了整个现代计算机发展的理论基础。

其突出贡献突出表现在以下几个方面：

1)   它回答了计算的能力范围；

2)   符合图灵机原理的不同技术实现在理论上具有相同的计算原理。

3)   它在理论上规范了计算机的实现思路。

图灵机是一种有限状态机

计算机的体系结构：冯·诺依曼结构

![img](单片机整理.assets/clip_image002.png)

为了克服运算器数据吞吐能力有限的缺点，演化出了改进型冯·诺依曼架构。

![img](单片机整理.assets/clip_image004.png)

改进型构架的各个模块的高速数据交换中心利用存储器这个大容量中介，极大的提高了效率。

计算机体系结构：是指根据属性和功能不同而划分的计算机理论组成部分及计算机基本工作原理、理论的总称。

嵌入式系统是以应用为中心，以计算机技术为基础，并且软硬件可裁剪， 嵌入到应用系统，对功能、可靠性、成本、体积、功耗有严格要求的专用的计算机系统。

单片机是一种集成电路芯片，把CPU、RAM、ROM、I/O接口和中断系统、定时器/计数器等功能（PWM、ADC/DAC……）集成到一块硅片上构成的一个芯片级微型计算机，在工控领域广泛应用。

嵌入式系统可以用单片机实现，也可以用其它可编程的电子器件实现

嵌入式系统是一个大类，单片机系统是其中一个重要的子类

**面向嵌入式应用的架构改进**

l 冯·诺依曼架构到哈佛结构的改进（区别：数据空间和程序空间是否分开）

l 流水线技术（ARM7和Cortex-M都支持三级流水线）

l 并行处理：指令级---超流水线；任务级---Intel的超线程；处理器级---多核

l 硬件加速：用硬件实现对性能影响大的软件环节，如媒体播放中的解码算法

l 层次设计和缓存：存储器层次结构，Cache

l 总线和交换式部件互连：如SPI、USB、AMBA

l 虚拟化技术

l 寄存器窗口

l 实时技术

早期的架构技术更重于硬件改进，而现在则更偏向于软件和应用需求。

**ARM，Cortex，STM32**

ARM：公司名称，以及该公司设计的低功耗CPU内核及其架构。

Advanced RISC Machine高级精简指令机器

该公司是全球领先的16/32位RISC微处理器知识产权设计供应商，通过将其高性能、低成本、低功耗的RISC微处理器、外围和系统芯片设计技术转让给合作伙伴来生产各具特色的芯片。ARM公司已成为移动通信、手持设备、多媒体数字消费嵌入式解决方案的RISC标准。

处理器特点：a. 小体积、低功耗、低成本而高性能； b.16/32位双指令集； c.全球的合作伙伴众多。

ARM7: ARMv4，低功耗的32位RISC处理器，采用冯诺依曼体系结构 

能够提供0.95DMIPS/MHz的三级流水线结构。代码密度高并兼容16位的Thumb指令集

ARM9: ARMv5，采用哈佛结构 ,5级整数流水线，指令执行效率更高，1.1DMIPS/MHz

支持32位ARM指令集和16位Thumb指令集，支持32位的高速AMBA总线接口

ARM11: ARM1136J-S是第一个执行ARMv6架构指令的处理器，主要特点： 

集成了具有独立的load-store和算术流水线的8级流水线

ARMv6指令包含了针对媒体处理的单指令流多数据流（SIMD）扩展

Cortex

基于ARMv7，哈佛结构，三级流水线

三类：高性能A，微控制器M，实时R。

Thumb-2技术（比纯32位代码少用 31％内存，比Thumb技术高38％性能）

采用哈佛结构的32位处理器内核，仅支持Thumb-2指令集不支持ARM指令集，具有高性能、低功耗与低电压操作特性，同时还保持了集成度高和易于开发的特点。

具有可嵌入式中断向量控制器NVIC，存储器保护单元MPU。

支持ucos，MDK RTX系统

STM32

意法半导体推出的基于cortex-M3的产品

管脚,软件和外设全线兼容

FLASH——32KB,64KB,128KB

RAM——6KB,10KB,20KB

封装——LQFP-48/LQFP-64/LQFP-100/BGA-100

电压范围2.0到3.6V

I/O电压容限为5V

两个系列：基本型STM32F101，36MHz；增强型STM32F103，72MHz。

增强型特点：

2V-3.6V 供电电压

5V I/O 电压容限

出色的时钟安全模式

带有唤醒的低功耗模式

内部RC

嵌入的RESET

-40/+85°C（工业级）

常见外设：USB,USART,SPI,I2C,GPIO,PWM,SDIO,I2S,ADC,DAC,TIM,IWDG,WWDG,RTC

**二、**  **cortex-M3**

指令集

仅支持Thumb-2指令（其中的少部分M3不支持）,不支持ARM指令集

Thumb-2扩充了Thumb

Thumb-2融合了32位ARM指令集和16位Thumb指令集，在Cortex-M内核上一个典型的Thumb-2应用程序与完全采用ARM指令完成的相同功能应用程序相比，代码大小减小到25%之内，而执行效率达到90%(当针对运行时间进行优化后)。

![img](单片机整理.assets/clip_image006.png)

![img](单片机整理.assets/clip_image008.png)

指令宽度选择

Thumb-2指令集中有许多指令都可产生16位或32位编码，可强制指定：

ADDS.N R1, R2, #2   ；Narrow，16位指令

ADDS.W R1, R2, #2   ；Wide，32位指令

指令集中有：数据处理指令，数据传送，算术运算，逻辑运算，测试 ，乘法，跳转指令，程序状态寄存器访问指令，加载/存储指令，特别指令

STR存储字数据

LDR加载字数据

ADD加法

SUB减法

CMP比较

CMN负数比较

B转移指令

BL带返回的转移指令（将返回地址保存到LR寄存器）

**内核结构**

32-bit微处理器：32-bit 数据路径, 32-bit 寄存器组, 32-bit 存储器接口。

哈佛架构：独立的指令总线和数据总线。这允许指令和数据在同一时间产生。

存储空间：4GB。

寄存器：通用寄存器 (R0 到 R15) 和 特殊寄存器。

运行模式：线程模式和处理模式；特权级和用户级。

中断和异常：内置的嵌套向量中断控制器NVIC；支持11 种系统异常外加240 种外部 IRQ

与CPU紧密耦合，缩短延时

系统定时器SYSTICK：24位的递减计数器，具有灵活的控制机制。

总线接口：若干总线接口允许 Cortex-M3 同时取指令和取数据。

 MPU：一个可选的存储器保护单元允许对特权访问和用户程序访问制定访问规则。

指令集：Thumb-2 指令集; 允许 32-位指令和16-位指令被同时使用。

固定的内部调试组件：提供调试操作支持和像断点调试这样的功能

**总线结构**

集成了一个AMBA AHB-Lite总线来连接系统外设，以降低系统集成的复杂性

支持不对齐的数据访问，使不同的数据类型可以在存储器中紧密衔接可显著降低SRAM的需求和系统成本

总线矩阵将处理器、调试接口连接到外部总线

总线矩阵连接到这些外部总线：

ICode总线，32位AHB-Lite总线，用于从指令空间中取指和取向量

DCode总线，32位AHB-Lite总线，主要用于数据访问。

系统总线，32位AHB-Lite总线，用于从系统空间中取指、取向量、读写数据和调试访问

APB，32位APB (v2.0)总线，用于从APB空间读写数据和调试访问

**寄存器**

通用寄存器

  注意：复位后的初始值是不可预料的

\1. R0~R7 (低寄存器): 

可以被所有 16-bit Thumb 指令和所有 32-bit Thumb-2 指令访问。

\2. R8~R12 (高寄存器):

可以被所有 Thumb-2 指令但只能被少数16-bit Thumb 指令访问。

R13 是堆栈指针。两个堆栈指针是分组的，所以在同一时间只有一个可见。

堆栈指针的最低两位总是0, 这意味着他们总是字对齐。

两个堆栈指针是:

\1. 主堆栈指针(MSP) : 这是默认的堆栈指针。

\2. 进程堆栈指针(PSP) : 被基本级别的应用程序代码所使用。

堆栈是由一块连续的内存和一个栈顶指针组成，用于实现“后进先出”的缓冲区。

堆栈指针用来进行堆栈存储器操作比如PUSH和POP。

Cortex-M3使用向下生长的满栈

R14 是链接（连续）寄存器 (LR). 当一个子程序或函数被调用时，LR用来存储返回的程序计数器。

R15 是程序计数器。存放当前指令地址。你可以在汇编语言中通过R15或PC访问它。当你读这个寄存器时，你会发现它的值和执行指令位置的值相差4。

特殊寄存器

程序状态寄存器 (PSRs)

程序状态寄存器可以分为三个状态寄存器：

\1. 应用 PSR (APSR)

\2. 中断 PSR (IPSR)

\3. 执行 PSR (EPSR)

PRIMASK, FAULTMASK 和 BASEPRI 寄存器

PRIMASK, FAULTMASK, 和 BASEPRI 寄存器被用来禁用异常。

![img](单片机整理.assets/clip_image010.png)

 

控制寄存器

控制寄存器被用来定义特权级和堆栈指针的选择。这个寄存器有两位。

![img](单片机整理.assets/clip_image012.png)

**存储器管理**

\1. 预先定义的内存映射指定了在访问某存储位置时使用哪个总线接口。

\2. Bit-band: 它提供了对内存或外设的bit数据的原子操作。

\3. 提供了非对齐传输和独占访问。

空间分配

![img](单片机整理.assets/clip_image014.png)

位带操作

Bit-band操作支持用一个单一的load/store操作来访问(读/写) 单个数据位。

Bit-band区域: 

\1. SRAM 的第一个1MB区域

\2. 外设区域的第一个1 MB 

它们可以通过一个单独的被称为bit-band alias的存储区域被访问。

计算方法：

SRAM：0x22000000+(A-0X20000000)*32+N*4;

外设：0x42000000+(A-0X40000000)*32+N*4;

**端模式**

Cortex-M3 支持小端和大端模式。

在 Cortex-M3 中大端的定义和 ARM7 中不同。 

在 ARM7TDMI中, 大端被称为字不变大端 然而在 Cortex-M3中, 大端被称为字节不变大端。

**存储保护单元**

MPU 提高了系统的可靠性：

\1. 阻止用户程序修改操作系统使用的数据。

\2. 将不同任务的数据分开。

\3. 允许内存区域被设置为只读。

\4. 发现异常的内存访问。

\5. 定义内存访问特征。

支持8个存储区段

**工作模式**

**![img](单片机整理.assets/clip_image016.png)**

特权级别提供了一种机制来保障访问存储器的关键区域，同时还提供了一个基本的安全模式。

通过写Control register[0]=1，软件在特权访问级别可以使程序转换到用户访问级别。

用户程序不能够通过写控制寄存器直接变回特权状态。 

它要经过一个异常处理程序设置Control register[0]=0使得处理器切换回特权访问级别。

**异常与中断**

编号为1到15是系统异常；余下的240个是外部中断。（向量表中共256条）

   异常是另一种形式的中断，由内核的内部错误、SysTick、SVCall等引起，而中断是由随机的外部事件引发的。（统称为异常）

   大部分的异常的优先级是可编程的。

中断号与优先级

![img](单片机整理.assets/clip_image018.png)![img](单片机整理.assets/clip_image020.png)

一个高优先级的异常可以抢占一个低优先级的异常.

复位, NMI, 和硬件错误有特定的优先级.

Cortex-M3 支持256级可编程异常.

减少优先级数可以通过减少优先级配置寄存器的一些低位来实现。

优先级可以进一步被分为2部分: 抢占优先和次优先。

对于不同的优先组设置，抢占优先字段和次优先级字段在优先级寄存器(最多8位)中的定义

抢占优先级决定了抢占行为

向量表

复位：异常类型1，向量地址是1乘4, 等于 0x00000004

NMI： 异常类型2，向量地址是

2 * 4 = 0x00000008 

地址 0x00000000 被用作MSP的开始值。

![img](单片机整理.assets/clip_image022.png)

Fault类异常：总线错误，内存管理错误，用法（Usage） 错误，硬件错误

错误的处理

一些可能的处理方法：

\1. 复位: 

使用VECTRESET控制位，复位处理器但不是整个芯片。这个位在NVIC中的Application Interrupt and Reset Control register中。

\2. 恢复Recover: 

解决引发错误异常的问题。

\3. 终止任务: 

若是有操作系统的系统， 则可以终止引发错误异常的任务并在必要时重启任务。

**三、**  **最小系统**

什么是最小系统？

  尽可能减少上层应用，能使系统运行的最小化模块配置。

最小系统的组成： ①电源、②时钟、③复位电路、④存储系统、⑤调试系统。

时钟模块——通常经ARM内部锁相环进行相应的倍频，以提供系统各模块运行所需的时钟频率输入

复位模块——实现对系统的复位

电源系统

调试系统

JTAG模块——实现对程序代码的下载和调试

UART模块——实现对调试信息的终端显示

存储系统：

Flash存储模块——存放启动代码、操作系统和用户应用程序代码

SDRAM模块——为系统运行提供动态存储空间，是系统代码运行的主要区域

Cortex-M3主要指标：0.19W/MHz，1.25DMIPS/MHz；

若达到5DMIPS的性能：Cortex-M3工作频率只需4MHz，功耗0.76W；51单片机，工作频率需60MHz，功耗30W；

 

STM32F103处理器系统频率为72MHz，处理器性能可达到90DMIPS，此时Cortex-M3功耗约14W左右。

在性能和功耗上达到了很高的水平！

电源及控制、复位电路

多个电源

VDD

外部电源通过VDD引脚提供，用于I/O和内部调压器

VDDA

外部模拟电压输入，用于ADC、复位模块、RC和PLL

VBAT

当VDD无效时，为RTC、外部32KHZ晶振和备份寄存器供电（通过电源切换实现）

VDDA/VSSA独立电源/地

2.0至3.6V：为ADC、复位、RC振荡器和PLL的模拟部分供电。使用ADC时，VDD不得小于2.4V。VREF+的电压范围2.4V-VDDA， VREF-引脚若有必须连接到VSSA。

VDD：主电源/工作电压

VSS：地

2.0至3.6V：通过内置调压器提供1.8V的电源，供内核使用、3.3V供I/O管脚。

VBAT：后备电池供电

   2.0 至3.6V

单片机电源脚上面再接电容主要是处理两种问题:1、滤除外界辐射的高频干扰；2、滤除单片机工作时自身产生的脉冲干扰

**内部电压保护复位电路**

系统复位

系统复位将清除时钟控制器CSR中的复位标志和备用域寄存器之外的所有寄存器。下列事件都将引起复位：

NRST: 外部异步复位引脚

窗口看门狗计数终止（WWDG复位） 

独立看门狗计数终止（IWDG复位） 

低功耗管理复位（待机与停止）

软件复位（SW复位）

电源复位

包括上电掉电复位及从待机模式中返回

复位后入口为x00000004。

备份域复位

**时钟系统**

STM32芯片为了实现低功耗，设计了一个功能完善但却非常复杂的时钟系统。

高速时钟是提供给芯片主体的主时钟，低速时钟只是提供给芯片中的RTC（实时时钟）及独立看门狗使用。

内部时钟是在芯片内部RC振荡器产生的，起振较快，芯片刚上电的时候使用内部高速时钟。

外部时钟信号是由外部的晶振输入的，精度和稳定性好，上电之后通过软件配置再转用外部时钟信号

在STM32中，一共有5个时钟源，分别是HSI、HSE、LSI、LSE、PLL

（1） HSI是高速内部时钟，RC振荡器，频率为8MHz；
 （2） HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围是4MHz – 16MHz；
 （3） LSI是低速内部时钟，RC振荡器，频率为40KHz；
 （4） LSE是低速外部时钟，接频率为32.768KHz的石英晶体；
 （5） PLL为锁相环倍频输出，严格的来说并不算一个独立的时钟源，PLL的输入可以接HSI/2、HSE或者HSE/2。倍频可选择为2 – 16倍，但是其输出频率最大不得超过72MHz。
 每个外设都配备了外设时钟的开关，当我们不使用某个外设时，可以把这个外设时钟关闭，从而降低STM32的整体功耗。

使用外设的第一个步骤，就是开启外设时钟。

**低功耗模式**

休（睡）眠模式： 

只有CPU停止工作，所有外设继续运行，在中断/事件发生时唤醒CPU，调压器1.8V区供电工作。

停止（机）模式： 

允许以最小的功耗来保持SRAM和寄存器的内容。 

1.8V区域的时钟都停止，PLL，HSI和HSE的 RC振荡器被禁能。

当外部中断源、PVD输出、RTC闹钟、或者USB唤醒信号，退出停止模式。

待机模式： 

追求最少的功耗，内部调压器被关闭，内核1.8V电源关闭。 

除了备份寄存器和待机电路，SRAM和寄存器的内容也会丢失。

RTC,IWDG和相关的时钟源不会停止。 

当外部复位（NRST引脚）、IWDG复位、WKUP引脚出现上升沿或者RTC闹钟时间到时，退出待机模式。

三种模式中，最低功耗的就是待机模式，在此模式下，最低只需要2uA左右的电流，其次是停机模式，大概需要20uA左右的电流

运行模式下降低功耗的方法

降低系统时钟

关闭APB和AHB总线上未被使用的外设时钟

**四、**  **GPIO****及外部中断**

![img](单片机整理.assets/clip_image024.png)

每个GPIO端口有：

![img](单片机整理.assets/clip_image026.png)

每个位可由软件配置成多种模式：

输入浮空、输入上拉、输入下拉、模拟输入、开漏输出、推挽输出、推挽复用功能和开漏复用功能

![img](单片机整理.assets/clip_image028.png)

复位期间和刚复位后，复用功能未开启，I/O端口被配置成浮空输入模式(CNFx[1:0]=01b，MODEx[1:0]=00b)。

复位后，JTAG引脚被置于输入上拉或下拉模式：

─PA15：JTDI置于上拉模式

─PA14：JTCK置于下拉模式

─PA13：JTMS置于上拉模式

─PB4： JNTRST置于上拉模式

当对GPIO个别位编程时，软件不需要禁止中断。

在单个写操作里，可以只更改一个或多个位，通过对“置位/复位寄存器”(GPIOx_BSRR/ GPIOx_BRR)中想要更改的位写’1’来实现，没被选择的位将不被更改。

所有的GPIO引脚有一个内部微弱的上拉和下拉，当它们被配置为输入时可以是激活的或者非激活的

所有端口都有外部中断能力。为了使用外部中断线，端口必须配置成输入模式。

复用功能

使用默认复用功能前必须对端口位配置寄存器编程：

对于复用的输入功能，端口必须配置成输入模式(浮空、上拉或下拉)且输入管脚必须由外部驱动

对于复用输出功能，端口必须配置成复用功能输出模式(推挽或开漏)。

引脚 和输出寄存器断开，并和片上外设的输出信号连接，若片上外设没有被激活，则输出不确定。

对于双向复用功能，端口位必须配置复用功能输出模式(推挽或开漏)。这时，输入驱动器被配置成浮空输入模式。

GPIO锁定机制

锁定机制允许冻结IO配置。当在一个端口位上执行了锁定(LOCK)程序，在下一次复位之前，将不能再更改端口位的配置。

输入配置

当I/O端口配置为输入时：

输出缓冲器被禁止

施密特触发输入被激活

根据输入配置(上拉，下拉或浮动)的不同，弱上拉和下拉电阻被连接

出现在I/O脚上的数据在每个APB2时钟被采样到输入数据寄存器

对输入数据寄存器的读访问可得到I/O状态

模拟输入配置

当I/O端口被配置为模拟输入配置时：

输出缓冲器被禁止；

禁止施密特触发输入，实现了每个模拟I/O引脚上的零消耗。施密特触发输出值被强置为’0’；

弱上拉和下拉电阻被禁止；

读取输入数据寄存器时数值为’0’。

输出配置

当I/O端口被配置为输出时：

输出缓冲器被激活

施密特触发输入被激活

弱上拉和下拉电阻被禁止

出现在I/O脚上的数据在每个APB2时钟被采样到输入数据寄存器

在开漏模式时，对输入数据寄存器的读访问可得到I/O状态

在推挽模式时，对输出数据寄存器的读访问得到最后一次写的值。

复用配置

当I/O端口被配置为复用功能时：

在开漏或推挽式配置中，输出缓冲器被打开

内置外设的信号驱动输出缓冲器(复用功能输出)

密特触发输入被激活

弱上拉和下拉电阻被禁止

在每个APB2时钟周期，出现在I/O脚上的数据被采样到输入数据寄存器

开漏模式时，读输入数据寄存器时可得到I/O口状态

在推挽模式时，读输出数据寄存器时可得到最后一次写的值

**常用函数与变量：**

RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOx,ENABLE);使能时钟

GPIO_InitTypeDef 初始化结构体，包括GPIO_Pin，GPIO_Speed，GPIO_Mode；

GPIO_Pin：取值为GPIO_Pin_None/x/All(x:0~15)

GPIO_Speed：取值为GPIO_Speed_2/10/50MHz

GPIO_Mode：取值为

GPIO_Mode_AIN 模拟输入

GPIO_Mode_IN_FLOATING 浮空输入

GPIO_Mode_IPD 下拉输入

GPIO_Mode_IPU 上拉输入

GPIO_Mode_Out_OD 开漏输出

GPIO_Mode_Out_PP 推挽输入

GPIO_Mode_AF_OD 复用开漏输出

GPIO_Mode_AF_PP 复用推挽输入

GPIO_Init(GPIOx, GPIO_InitTypeDef*);初始化函数(x:A~F)

GPIO_SetBits(GPIOx,GPIO_Pin_x);置位函数

GPIO_ResetBits(GPIOx,GPIO_Pin_x);复位函数

**位运算**

左移运算符（<<）

左移１位相当于该数乘以２；

左移２位相当于该数乘以2^2＝４,15＜＜2=60，即乘了４。但此结论只适用于该数左移时被溢出舍弃的高位中不包含１的情况

右移运算符(>>)

右移运算符是a>>2表示将a的各二进制位右移2位，移到右端的低位被舍弃；对无符号数，高位补0。

“按位与”运算符（＆）

按位与是指：参加运算的两个数据，按二进制位进行“与”运算。如果两个相应的二进制位都为１，则该位的结果值为１；否则为０。

“按位或”运算符（|）

两个相应的二进制位中只要有一个为１，该位的结果值为１。

即 ０|０＝０，０|１＝１，１|０＝１，１|１＝１

“取反”运算符（～）

～是一个单目（元）运算符，用来对一个二进制数按位取反，即将０变１，将１变０。例如，～025是对八进制数25（即二进制数０００１０１０１）按位求反。

“异或”运算符（∧）

异或运算符∧也称XOR运算符。规则是：

​    同为０（假）异为１（真）

即：0∧0=0，0∧1=1，1∧0=1， 1∧1=0

**外部中断和中断控制器**

嵌套向量中断控制器 NVIC

60个可屏蔽中断通道

16个可编程的优先等级(使用了4位中断优先级)

低延迟的异常和中断处理

电源管理控制

系统控制寄存器的实现

NVIC和处理器核的接口紧密相连，可以实现低延迟的中断处理和有效地处理晚到的中断。

(不包含16个Cortex™-M3的中断线)

stm32f103，一共有16个内核中断+60个中断=76个中断

外部中断/事件控制器(EXTI)

EXTI由19个可以产生事件/中断要求的边沿检测器组成。

每个输入线可以独立地配置输入模式(中断或事件)和对应的触发方式(上升沿、下降沿、双边沿都触发)。

每个输入线都可以被独立的屏蔽。挂起寄存器保持着状态线的中断要求。

可以检测到脉冲宽度小于APB2时钟宽度的外部信号。参见数据手册中电气特性部分的相关参数。

EXTI可分为两大部分功能，一个是产生中断，另一个是产生事件，这两个功能从硬件上就有所不同。

硬件中断/事件配置

配置19个线路做为中断源：

配置19个中断线的屏蔽位(EXTI_IMR)

配置所选中断线的触发选择位(EXTI_RTSR和EXTI_FTSR)；

配置那些与外部中断控制器(EXTI)相关的NVIC中断通道的使能和屏蔽位，使得19个中断线中的请求可以被正确地响应。

配置19个线路为硬件事件源：

配置19个事件线的屏蔽位(EXTI_EMR)

配置事件线的触发选择位(EXTI_RTSR和EXTI_FTSR)

STM32 的每一个GPIO都能配置成一个外部中断触发源，根据引脚序号将多个源分成不同的组，如：PA0/PB0/PC0/PD0/PE0/PF0/PG0为第一组，一共有16 组，每一组中同时只能有一个中断触发源工作

![img](单片机整理.assets/clip_image030.png)

软件中断/事件的选择

19个线路可以被配置成软件中断/事件线，下面是产生软件中断的过程：

配置19个中断/事件线屏蔽位(EXTI_IMR, EXTI_EMR)

设置软件中断寄存器的请求位(EXTI_SWIER）

常用函数与结构体：

NVIC_InitTyoeDef：NVIC初始化结构体，包括：

NVIC_IRQChannel中断源（格式xx_IRQn）

NVIC_IRQChannelPreemptionPriority抢占优先级

NVIC_IRQChannelSubPriority子优先级

NVIC_IRQChannelCmd中断通道控制

NVIC_PriorityGroupConfig(NVIC_PriorityGroup_x);设置优先级组

NVIC_Init(NVIC_InitTyoeDef*)NVIC初始化

 

RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);使能复用时钟

EXTI_InitTypeDef：EXTI初始化结构体，包括：

EXTI_Line：事件线（EXTI_Line0~18）

EXTI_Mode：EXTI 模式选择，可选为产生中断(EXTI_Mode_Interrupt)或者产生事

件(EXTI_Mode_Event)。

EXTI_Trigger：EXTI 边沿触发事件，可选上升沿触发(EXTI_Trigger_Rising)、下

降沿触发( EXTI_Trigger_Falling) 或者上升沿和下降沿都触发

( EXTI_Trigger_Rising_Falling)。

EXTI_LineCmd：控制是否使能EXTI 线，可选使能EXTI 线(ENABLE)或禁用

(DISABLE)。

GPIO_EXTILineConfig(GPIO_Portsourcex, GPIO_Pinsourcex);选择信号源

void EXTIx_IRQHandler(void)//中断处理函数

{

​       if (EXTI_GetITStatus(EXTI_Linex) != RESET) {

​       //处理部分

​       EXTI_ClearITPendingBit(EXTI_Linex);

​       }

}

**五、**  **TIM****定时器**

STM32F的定时器简介

有11个：

2个高级控制定时器：TIM1、TIM8

互补输出、能够产生三对PWM互补输出，常用于电动机的控制，它们的时钟由APB2的输出产生。

4个通用定时器：TIM2~5

2个基本定时器：TIM6~7

2个看门狗定时器

1个系统Tick

通用定时器工作原理

一个通过可编程预分频器驱动的16位自动装载计数器

功能包括：

16位向上、向下、向上/向下自动装载计数器

16位可编程预分频器

具备4个独立通道：输入捕获、输出比较、PWM生成、单脉冲模式输出

使用外部信号控制定时器和定时器互连的同步电路

可以通过事件产生DMA和中断，中断类型丰富

支持针对定位的增量编码器和霍尔传感器电路

基本定时器

16位自动装载计数器

功能包括：

16位自动装载累加计数器

16位可编程预分频器

触发DAC同步电路

在更新事件时产生中断/DMA请求

通用定时器与时基功能相关的寄存器：

计数器寄存器：TIMx_CNT

预分频器寄存器：TIMx_PSC

自动装载寄存器：TIMx_ARR

计数器模式

向上计数模式：从0计数到设定的数值，然后重新从0开始计数并且产生一个溢出事件。

向下计数模式：从设定的数值开始向下计数到0，然后自动从设定的数值重新向下计数，并产生一个向下溢出事件。

中央对齐模式（向上/向下计数）: 从0开始计数到设定的数值-1，产生一个溢出事件，然后向下计数到1并且产生一个下溢事件；再从0开始重新计数。

通用定时器的定时中断编程

TIM_TimeBaseInitTypeDef定时器初始化结构体

(1) TIM_Prescaler：定时器预分频器设置，时钟源经该预分频器才是定时器时钟，它设定

TIMx_PSC 寄存器的值。可设置范围为0 至65535，实现1 至65536 分频。

(2) TIM_CounterMode：定时器计数方式，可是在为向上计数、向下计数以及三种中心对

齐模式。基本定时器只能是向上计数，即TIMx_CNT 只能从0 开始递增，并且无需初

始化。

(3) TIM_Period：定时器周期，实际就是设定自动重载寄存器的值，在事件生成时更新到

影子寄存器。可设置范围为0 至65535。

(4) TIM_ClockDivision：时钟分频，设置定时器时钟CK_INT 频率与数字滤波器采样时钟

频率分频比，基本定时器没有此功能，不用设置。

(5) TIM_RepetitionCounter：重复计数器，属于高级控制寄存器专用寄存器位，利用它可

以非常容易控制输出PWM的个数。这里不用设置。

虽然定时器基本初始化结构体有5 个成员，但对于基本定时器只需设置其中两个就可

以，想想使用基本定时器就是简单。

计算最大计数值:

定时值= (计数值+1) * 计数输入时钟周期 * (预分频值+1）

设：要定时1秒，系统时钟72MHZ，预分频值为7199

则：计数值为9999 (10000-1)

对于通用定时器TIM2、TIM3、TIM4和TIM5，利用库函数设置定时器如下:

1) 使能定时器TIM_X的时钟(X=2,3,4,5)

RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIMX,ENABLE);

2) 将相应分频数和计数值分别赋值

//自动重装的计数值 

TIM_TimeBaseStructure.TIM_Period = (10000 - 1);

// 这个就是预分频系数

TIM_TimeBaseStructure.TIM_Prescaler =(7200-1) ;

//数字滤波器，定时时不涉及此功能，为零即可

TIM_TimeBaseStructure.TIM_ClockDivision = 0;

//计数模式选择，此处设置为向上模式

TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounteMode_Up;

//定时基本设置(X=2、3、4、5)

TIM_TimeBaseInit(TIMX, &TIM_TimeBaseStructure);

3) 允许时钟中断

//开定时器X溢出中断

TIM_ITConfig(TIM5, TIM_IT_Update, ENABLE);

4) 中断配置

NVIC_Init(&NVIC_InitStructure); //定时器中断配置

5) 中断函数  在stm32f10x_it.c添加定时器TIMX的中断函数：

void TIMX_IRQHandler(void) { 

//如果定时器产生了中断（X=2、3、4、5）

if (TIM_GetITStatus(TIMX, TIM_IT_Update) != RESET) {

   //自己需要去完成的事情和相关判断} 

​    TIM_ClearITPendingBit(TIM5, TIM_IT_Update); //清除中断 

   }

}

6) 开启定时器

//计数器使能，开始工作

TIM_Cmd(TIMX, ENABLE); 