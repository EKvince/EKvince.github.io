# 第一章 软件工程学概论

## 1.1 软件生命周期

- 问题定义：要解决什么问题

- 可行性研究：对于所确定的问题有行得通的解决方法

- 需求分析：为了解决这个问题，目标系统必须做什么

- 总体设计：怎么实现目标系统

- 详细设计：怎么具体地实现系统

- 编码和单元测试：写出正确容易理解，维护的程序模块

- 综合测试：通过测试使软件达到预定需求

- 软件维护：使系统持久地满足用户的需要

## 1.2 软件过程

### 1.2.1      过程模型

- 瀑布模型

- 快速原型模型

- 增量模型

- 微软过程

#### 1.2.1.1  瀑布模型

特点：

**阶段间具有顺序性和依赖性**

**推迟实现**

​          区分逻辑设计和物理设计，推迟程序的物理实现

**质量保证（文本驱动）** 

----

缺点：

开发过程不能逆转

![image-20210223210230740](软件工程.assets/image-20210223210230740.png)

#### 1.2.1.2  快速原型模型

快速建立可运行程序，完成最终产品的功能子集

特点：

- 本质快速

- 获取用户需求，适应需求变化

- 利于开发与培训同步

------

应用范围：：

- 用户需求不完成，不准确，有快速原型开发工具
- 项目招投标
- 产品移植，升级，客户化

![image-20210223210343566](软件工程.assets/image-20210223210343566.png)

#### 1.2.1.3  增量模型

把软件作为一系列增量构建开发

优点：

- 分阶段交付产品
- 减少全新产品给客户带来心理上的影响

![image-20210223210405725](软件工程.assets/image-20210223210405725.png)

#### 1.2.1.4  螺旋模型

瀑布模型+风险分析

![image-20210223210442968](软件工程.assets/image-20210223210442968.png)

#### 1.2.1.5  喷泉模型

迭代：

- 阶段间的迭代

- 阶段内工作步骤的迭代

------

工作重点：分析过程

**无缝连接**：分析得到的对象模型也适用设计和实现

![image-20210223211016892](软件工程.assets/image-20210223211016892.png)

# 第二章 可行性研究

## **2.1可行性研究的任务**

用最小代价在尽可能短的时间内趋稳定问题是否能解决

- **不是解决问题**，**而是确定问题是否值得去解决**

- **分析几种可能解法，每种解法的可能性**
  1. 技术可行性
  2. 经济可行性
  3. 操作可行性
- 最根本的任务是对以后的行动方针提出建议

## 2.2可行性研究过程

步骤：

1. **复查系统规模和目标**

   确保正在解决的问题是要求解决的问题

2. **研究现有系统**

   - **新系统能完成现有系统的基本功能**
   - 新系统能解决现有系统中存在的问题
   - 画出描绘现有系统的高层系统流程图

3. **导出新系统的高层逻辑模型**

   以现有的物理系统出发，导出现有系统的逻辑模型

4. **进一步定义问题**

   再次复查

5. **导出和评价供选择的解法**

   - 导出几种高层物理解

   - 对每个解进行可行性分析

6. **推荐行动方针**

   选择好解法及理由

7. **草拟开发计划**

   进度表，人员资源，成本

8. **书写文档提交审查**

   

![image-20201207133256457](软件工程.assets/image-20201207133256457.png)

# 第三章 需求分析

### 3.1需求分析的任务

- 基本任务
  - 系统必须做什么
  - 分析软件需求和书写需求规格说明书

![image-20201207134342818](软件工程.assets/image-20201207134342818.png)

## 3.2获取需求

访谈，调查等

## ==3.3数据流求精==

- 信息处理系统的基本功能

  把输入数据转变为需要的输出信息

- 结构化分析方法

  面对数据流，==自顶向下逐步求精==进行需求分析

- 数据流图(DFD)符号

![image-20201207135544205](软件工程.assets/image-20201207135544205.png)

**画数据流图步骤**：

1. 画系统的输入和输出（顶层图），上下文图
2. 画系统内部图（0层图）
   - 分解顶层图中的加工，并用数据流将这些加工连接起来
   - 在数据流的组成或值发生变化的地方画一个加工
   - 根据系统功能确定加工
3. 画加工的内部

### 3.3.1 顶层图



<img src="软件工程.assets/image-20201207141857565.png" alt="image-20201207141857565" style="zoom:50%;" />

### 3.3.2 0层图

<img src="软件工程.assets/image-20201207141919806.png" alt="image-20201207141919806" style="zoom:50%;" />

加工->存储

存储->加工

但不可能==存储->存储==

### 3.3.3 1层图

<img src="软件工程.assets/image-20201207143253450.png" alt="image-20201207143253450" style="zoom: 67%;" />



### 3.3.4 注意点

- 数据流的分层
- 加工编号
- 父子图的数据平衡
- 画数据流而不是画控制流

### 3.3.5 分析建模与规格说明

**三种模型**：

- 功能模型：数据流图

- 数据模型：实体-联系图

- 行为模型：状态转换图

### 3.3.6 验证软件需求

需求验证四个方面：

1. 一致性：需求不矛盾
2. 完整性：每一个功能
3. 现实性：可以实现
4. 有效性：可以解决

# 第四章 自学

# 第五章 总体设计

- 总体设计的任务

- 设计过程

## 5.1 总体设计的任务

- 概括地说，系统应该如何实现

- “概要设计”或者“初步设计”
  - 系统设计
    - 划分系统：程序，人工过程，文件等组件关系
  - 结构设计
    - 划分程序：模块以及模块间的关系

- 设计过程

  1. 设想方案

     - 逻辑模型->各种可能的实现方案

  2. 选取方案

  3. 推荐方案

  4. 功能分解

     - 结构设计

       确定程序由哪些模块构成

  5. 设计软件结构

     把模块组织成良好的层次系统

  6. 设计数据库

  7. 制定方案

  8. 书写文档

  9. 复审

## 5.2 画图工具

- HIPO图
- 层次图
- 结构图

- HIPO图

  层次图+IPO图

- 结构图

  各模块之间的调用关系和数据传递

## 5.3 面向数据流的设计方法

### 5.5.1 结构化设计方法（SD方法）

基本思想：DFD->结构图

信息流类型：变换流、事物流

任何软件都可以用数据流图的方法表示

1. **变换流**

   ![image-20201220140835356](软件工程.assets/image-20201220140835356.png)

2. **事务流**

   ![image-20201220140855730](软件工程.assets/image-20201220140855730.png)

   

### 5.5.2 变化分析步骤（分成输入，处理，输出三模块）

1. 确定输入/输出流的边界，孤立出变换中心（数据流本质有没有变化

2. 完成第一级分解，设计系统的上层模块

   ![image-20201220141231192](软件工程.assets/image-20201220141231192.png)

3. 完成第二级分解

   I ：将每个遇到的处理器映射成相应的层模块

   P：每个处理直接对应下层模块

   O：由外界直接外推

   ![image-20201220141250495](软件工程.assets/image-20201220141250495.png)

   4.精简模块

   ![image-20201220141525506](软件工程.assets/image-20201220141525506.png)

   ![image-20201220141543021](软件工程.assets/image-20201220141543021.png)

   ![image-20201220141555351](软件工程.assets/image-20201220141555351.png)

   

### 5.5.3 事务分析

事物流映射成的软件结构包括==一个接收分支==和==一个发送分支==

它的某个加工，分离成许多分散的数据流，形成许多加工路径，并且根据输入值选择其中一个路径来执行。

![image-20201220142348906](软件工程.assets/image-20201220142348906.png)

![image-20201220142413392](软件工程.assets/image-20201220142413392.png)

![image-20201220142431201](软件工程.assets/image-20201220142431201.png)

![image-20201220142740076](软件工程.assets/image-20201220142740076.png)

![image-20201220142442188](软件工程.assets/image-20201220142442188.png)

![image-20201220142551271](软件工程.assets/image-20201220142551271.png)

# 第六章 详细设计

- 任务
- 结构程序设计
- 详细设计方法

## 6.1 任务

怎么具体地实现目标系统

==简明易懂==

## 6.2 特点

1. 自顶向下逐步求精
2. 单入单出控制结构
3. 结构化定理

## 6.3 详细设计工具

- 程序流程图（FC
- 盒图（N-S图
- PAD图
- 判断表和判定树
- 过程设计语言（PDL

### 6.3.1 控制结构

- 顺序结构等

### 6.3.2 扩展符号

### 6.3.3 程序流程图

![img](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3199659672,134596788&fm=26&gp=0.jpg)

### 6.3.4 盒图

![image-20201221141347099](软件工程.assets/image-20201221141347099.png)

特点：

- 不允许随意转移控制
- 局部以及全程数据的作用域易见
- 易表现嵌套关系

### 6.3.5 PAD图

问题分析图

![img](https://bkimg.cdn.bcebos.com/pic/267f9e2f07082838234134adb899a9014c08f13f?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U3Mg==,g_7,xp_5,yp_5)

### 6.3.6 判定表&判定树

- 表示复杂条件组合与动作之间的对应关系
- 示例：航空行李托运费计算

#### 6.3.6.1 判定表

![image-20201221144117049](软件工程.assets/image-20201221144117049.png)

6.4 PDL

过程设计语言

特点：

- 固定外语法

- 内语法

# 第七章 实现

- 主要任务
- 编码风格
- 软件测试基础
- 测试技术

## 主要任务

- 编码
  - 把软件设计结果翻译成程序
  - 程序的质量主要取决于软件设计的质量
- 测试
  - 对软件规格说明，设计和编码的最后复审
  - 开发总工作量的40%以上
  - ==测试目的==：尽可能多地发现错误
  - 调试目的：改正错误

## 编码风格

- 使代码容易读
- 更容易理解，错误更少
- KIS simple

## 软件测试基础

- 测试目标：发现错误
- 软件测试准则
  - pareto原理：80%的错误可能是20%模块造成的
  - 从“小规模”测试逐步到“大规模”测试
  - 穷举不可能
  - 由独立第三方从事测试工作
- 测试方法
  - 黑盒测试：功能测试或数据驱动测试
    - 基于规格说明的测试
    - 黑盒测试，功能测试或者输入输出驱动测试
      - 等价划分
        - 输入域划分为等价类
          - 有效类：有意义数据集
          - 无效类：无意义输入数据集
        - 取类中典型值
        - 划分等价类的原则
          - 值范围：1个有效类，2个无效类
          - 。。。。。
        - 设计测试用例
          - 设计新测试用例，尽可能多地覆盖尚未被覆盖的有效等价类
          - 设计新测试用例，==覆盖一个而且只覆盖一个==无效类
      - 边界值分析
        - 边界最容易发生错误
        - 等价类边界：等于，刚小于和刚大于边界的值
  - 白盒测试：结构测试或逻辑驱动测试
    - 测试用例
      - 测试数据和预期的输出结果
      - 选用少量“最有效的”测试数据
    - 逻辑覆盖
      - 以==程序内部逻辑结构为基础==设计测试
    - 语句覆盖
      - 足够多的测试用例
      - ==每个语句==至少执行一次
    - 判定覆盖
      - 分支覆盖
      - ==每一条边==至少一次
    - 条件覆盖
      - 每个条件的==每个取值==，==每个语句==至少一次
    - 判定条件覆盖
      - 每判定，每判定的每条件
    - 条件组合覆盖
      - 每判定的每条件组合至少一次

## 软件测试步骤

- 单元测试

  测试基本单元-模块，针对编码和详细设计

  测试局部路径和局部的数据

  1. 计算机测试

     - 驱动程序

     - 存根程序

- 集成测试：测试和组装软件

  1. 子系统测试：按软件结构组装模块

  2. 系统测试：子系统装配成系统

  3. 集成方法

     - 非渐增式集成

       分别测试每个模块

     - 渐增式集成

       逐步把下一个被测模块同已测好的模块进行集成

       - 问题

         需要存根和驱动，在测试完成后抛弃

         缺乏错误隔离手段

     - 自顶向下集成

       m1调用m2：m1在m2之前要被实现和集成

       - 优点

         错误隔离

         存根不浪费，可以扩展成相应的实际模块

         深度优先可以早期实现一个功能

         能够较早发现设计缺陷

       - 问题

         可复用模块（底层模块）测试不充分

         产品设计得越好，模块的测试可能越不彻底

     - 自底向上集成

       下层模块比上层模块先实现

       - 优点

         操作模块得到充分测试

         错误隔离

     - 混合式集成

     - 三明治式集成

- 验收测试

  - 用户参与，用实际数据验证软件的有效性
  - α测试，β测试

- 平行运行

- 回归测试

# 第十章 面对对象的概念

- 传统方法
  - 以算法为核心
  - 数据和处理分离
  - 软件由模块组成，模块间具有调用关系
  - 问题空间与解空间在结构上不一致，即“语义断层”

- 面向对象方法
  - 以对象为核心，数据以及数据上的操作构成对象
  - 软件由对象构成，对象间用消息通信
  - 问题空间与解空间在结构上尽可能一致
  - 面向对象=对象+类+继承+消息通信
- 面向对象建模
  - 功能模型：系统功能。数据流图，用例图
    - 用例图
      - 描述外部行为者所理解的系统功能
      - 确定系统变界
      - 确定用例
      - 简述行为者和用例
      - 用例描述
    - 用例模型结构
      - 包含
        - 多个用例可以重用的行为段
        - 包含是无条件的
      - 扩展
        - 有条件地扩展已有用例的行为
        - 在不改变原始用例的情况下增加用例行为
      - 继承
  - 对象模型：系统的数据结构：类图，对象图
    - 对象模型的层次
      - 五个层次
      - 主题
      - 类-对象
      - 结构
      - 属性
      - 方法
    - 对象模型-类图
      - 类间关系
        1. 关联：两类对象之间的某种语义上的联系
        2. 聚集：类对象之间整体域部分关系
        3. 泛化：类对象之间“一般-特殊”关系
      - 候选类-&-对象
      - 筛选关联
      - 划分主题
      - 边界组件
      - 服务组件
      - 实体组件
  - 动态模型：系统的控制结构：活动图，状态图，顺序图等

## 10.2 鲁棒性分析

输入：用例模型，域模型

输出：设计模型

### 10.2.1 边界组件

- 抽取用户界面，通信接口
- 用户接口组件
- 每个边界组件至少与一个参与者关联起来

### 10.2.2 服务组件

协调，序列化和控制其他对象

==隔离==所有从边界组件到实体组件的更改

### 10.2.3 实体组件

长期存在，持久性的信息

### 10.2.4 鲁棒性分析过程

1. 选择一个用例
2. 构建用例对应的协作图（不考
   1. 识别支持用例活动的设计组件
   2. 画出组件的关联
3. 顺序图（考

## 10.3 顺序图

协作图可以转换为顺序图

按第一次动作的时间顺序安排协作对象



## 10.4 状态图

描述对象的状态以及引起状态迁移的事件，来表示对象的行为

- 状态：对象满足某些条件，执行某些活动或者等待某些事件。

- 活动：对象达到某种状态时所作的处理
- 事件：在某个特定时刻发生的事情，引起状态迁移
- 迁移：两个状态间的关系。

![image-20210301143011399](软件工程.assets/image-20210301143011399.png)

### 10.4.1 画状态图

- 针对顺序图的类
  - 输入线：状态图的事件
  - 射出线：状态的行为
  - 两个事件之间的间隔就是一个状态
- 如果明确给出几个状态名称，先画出那几个状态的图形，再进行连接

## 10.5 定义服务

- 常规行为
  - 读写类属性的操作。无需在对象图中显式表示
- 从事件导出操作
- 利用继承减少冗余操作

# 第十一章 面向对象设计

## 11.1面向对象设计准则

设计模式（不考）

- 模块化，抽象，信息隐藏
- ==耦合==（概念题
  1. 交互耦合
  2. 继承耦合
- ==内聚==
  1. 服务内聚
  2. 类内聚
  3. 一般-特殊内聚

### 11.1.1 耦合

- 内容耦合
- 共用耦合（全局变量
- 控制耦合
- 印记（特征）耦合
- 数据耦合
- 尽量低耦合，尽量数据耦合

### 11.1.2 内聚

内聚程度最高:信息性内聚（每个操作都有各自的入口点，每个操作的代码相对独立，而且都在相同数据上完成

内聚程度最低：偶然性内聚（模块只是偶然性存放

逻辑性内聚（模块之间有部分功能相同

时间性内聚（中断程序，在同一时间使用功能

过程性内聚（过程中功能实现

通信性内聚（通过公共数据关联

功能性内聚 （最好：**一个模块一个功能**

### 11.1.3 软件重用

- 重用

  稍加修改后重复利用

- 软件重用层次

  知识重用

  方法和标准的重用

  软件成分的重用

### 11.1.4 基本概念-模式的基本要素

- 四个要素：

  - 模式名称

  - 问题

    - 用户接口容易改变

      不同用户有不同接口

      接口与功能的交织，导致开发维护几个不同的软件系统

    - 约束

      数据在不同模块呈现不同形式

  - 解决方案

  - 效果

- 模型-视图-控制器

- 结构

- 设计模式

  - 桥接模式

    两种API

    Client->Shape->Drawing(形状存在Shape中，Drawing保存画图方式)

  - 修饰模式

    - 汉堡包模型

      在基础上添加元素

      解决方案：

      继承关系转变为组成关系（加料汉堡中，添加的调料各自为个体对加料汉堡进行组合

  - 访问者 示例：编译器

    独立增加新操作，使结点独立于作用于操作上

    将所有节点类中相关的操作包装在一个独立的类中（访问者类中包含了相关操作功能

    访问者具备（类型检测/各种操作）功能

